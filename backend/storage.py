"""
JSON file-based storage for actions.

This module provides persistence for:
- ProposedAction: Actions generated by the LLM

Note: Context storage has been moved to context_storage.py (Qdrant-backed).
Storage files are created in a `data/` directory relative to this module.
"""
from __future__ import annotations

import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from .config import settings
from .models import ActionType, ProposedAction, SourceType


# --------------------------------------------------------------------------- #
# Configuration
# --------------------------------------------------------------------------- #

ACTIONS_FILE = settings.data_dir / "actions.json"

# Auto-incrementing action ID
_next_action_id: int = 1

# --------------------------------------------------------------------------- #
# Low-level JSON helpers
# --------------------------------------------------------------------------- #

def _load_actions_raw() -> List[Dict[str, Any]]:
    """Load raw action data from JSON file."""
    try:
        return json.loads(ACTIONS_FILE.read_text())
    except (json.JSONDecodeError, FileNotFoundError):
        return []


def _save_actions_raw(data: List[Dict[str, Any]]):
    """Save raw action data to JSON file."""
    ACTIONS_FILE.write_text(json.dumps(data, indent=2, default=str))


def _action_to_dict(action: ProposedAction) -> Dict[str, Any]:
    """Convert ProposedAction to dict for JSON storage."""
    return {
        "id": action.id,
        "context_id": action.context_id,
        "type": action.type.value,
        "payload": action.payload,
        "confidence": action.confidence,
        "status": action.status,
        "created_at": action.created_at.isoformat(),
        "source_type": action.source_type.value,
        "sender": action.sender,
        "summary": action.summary,
    }


def _dict_to_action(data: Dict[str, Any]) -> ProposedAction:
    """Convert dict from JSON to ProposedAction."""
    return ProposedAction(
        id=data["id"],
        context_id=data["context_id"],
        type=ActionType(data["type"]),
        payload=data.get("payload", {}),
        confidence=data.get("confidence", 0.5),
        status=data.get("status", "pending"),
        created_at=datetime.fromisoformat(data["created_at"]),
        source_type=SourceType(data.get("source_type")),
        sender=data.get("sender"),
        summary=data.get("summary"),
    )


# --------------------------------------------------------------------------- #
# Action Operations
# --------------------------------------------------------------------------- #

def get_next_action_id() -> int:
    """Get the next available action ID."""
    global _next_action_id
    nid = _next_action_id
    _next_action_id += 1
    return nid


def save_action(action: ProposedAction, notify: bool = True) -> ProposedAction:
    """
    Save an action. Updates if exists (by id), otherwise appends.
    Returns the saved action.
    
    Args:
        action: The action to save
        notify: If True, send push notification for new actions (default True)
    """
    print(f"Saving action: {action.type}")
    actions = _load_actions_raw()
    
    # Check for existing by id
    is_new = True
    for i, act in enumerate(actions):
        if act["id"] == action.id:
            actions[i] = _action_to_dict(action)
            _save_actions_raw(actions)
            is_new = False
            return action
    
    # Append new
    actions.append(_action_to_dict(action))
    _save_actions_raw(actions)
    
    # Send push notification for new actions
    if is_new and notify:
        try:
            from .push import notify_new_action
            notify_new_action(
                action_type=action.type.value,
                summary=action.summary,
                action_id=action.id,
            )
        except Exception as e:
            # Don't fail action save if push notification fails
            print(f"Failed to send push notification: {e}")
    
    return action


def get_action(action_id: int) -> Optional[ProposedAction]:
    """Get an action by its ID."""
    actions = _load_actions_raw()
    for act in actions:
        if act["id"] == action_id:
            return _dict_to_action(act)
    return None


def list_actions(
    status: Optional[str] = None,
    context_id: Optional[str] = None,
    limit: Optional[int] = None,
    order_desc: bool = True,
) -> List[ProposedAction]:
    """
    List actions with optional filtering.
    
    Args:
        status: Filter by status (pending, executed, skipped, error)
        context_id: Filter by the context that triggered the action
        limit: Maximum number of items to return
        order_desc: If True, return newest first (by created_at)
    """
    actions = _load_actions_raw()
    
    # Filter
    if status is not None:
        actions = [a for a in actions if a.get("status") == status]
    
    if context_id is not None:
        actions = [a for a in actions if a.get("context_id") == context_id]
    
    # Sort by created_at
    actions.sort(
        key=lambda a: a.get("created_at", ""),
        reverse=order_desc
    )
    
    # Limit
    if limit is not None:
        actions = actions[:limit]
    
    return [_dict_to_action(a) for a in actions]


def update_action_status(action_id: int, status: str) -> Optional[ProposedAction]:
    """Update an action's status. Returns the updated action or None if not found."""
    actions = _load_actions_raw()
    
    for act in actions:
        if act["id"] == action_id:
            act["status"] = status
            _save_actions_raw(actions)
            return _dict_to_action(act)
    
    return None


def update_action_payload(action_id: int, payload: Dict[str, Any]) -> Optional[ProposedAction]:
    """Update an action's payload. Returns the updated action or None if not found."""
    actions = _load_actions_raw()
    
    for act in actions:
        if act["id"] == action_id:
            act["payload"] = payload
            _save_actions_raw(actions)
            return _dict_to_action(act)
    
    return None


def get_actions_for_context(context_id: str) -> List[ProposedAction]:
    """Get all actions associated with a specific context."""
    return list_actions(context_id=context_id)


# --------------------------------------------------------------------------- #
# Utility Functions
# --------------------------------------------------------------------------- #

def clear_all_actions():
    """Clear all stored actions. Use with caution!"""
    global _next_action_id
    _save_actions_raw([])
    _next_action_id = 1


# --------------------------------------------------------------------------- #
# Module Initialization
# --------------------------------------------------------------------------- #

def _init_action_id():
    """Initialize the next action ID based on existing actions."""
    global _next_action_id
    
    actions = _load_actions_raw()
    if actions:
        max_id = max(a.get("id", 0) for a in actions)
        _next_action_id = max_id + 1


# Initialize on module load
_init_action_id()
