"""
Supabase-backed storage for actions.

This module provides persistence for:
- ProposedAction: Actions generated by the LLM

Note: Context storage has been moved to context_storage.py (Qdrant-backed).
"""
from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, List, Optional

from .models import ActionType, ExecutionResult, ProposedAction, SourceType
from .supabase_client import get_db


# --------------------------------------------------------------------------- #
# Conversion Helpers
# --------------------------------------------------------------------------- #

def _action_to_dict(action: ProposedAction, user_id: str) -> Dict[str, Any]:
    """Convert ProposedAction to dict for Supabase storage."""
    return {
        "user_id": user_id,
        "context_id": action.context_id,
        "type": action.type.value,
        "payload": action.payload,
        "confidence": action.confidence,
        "status": action.status,
        "created_at": action.created_at.isoformat(),
        "source_type": action.source_type.value,
        "sender": action.sender,
        "summary": action.summary,
        "result": action.result,
    }


def _dict_to_action(data: Dict[str, Any]) -> ProposedAction:
    """Convert dict from Supabase to ProposedAction."""
    created_at = data["created_at"]
    if isinstance(created_at, str):
        # Handle ISO format with timezone
        created_at = datetime.fromisoformat(created_at.replace("Z", "+00:00"))
    
    return ProposedAction(
        id=data["id"],
        context_id=data["context_id"],
        type=ActionType(data["type"]),
        payload=data.get("payload", {}),
        confidence=data.get("confidence", 0.5),
        status=data.get("status", "pending"),
        created_at=created_at,
        source_type=SourceType(data.get("source_type")),
        sender=data.get("sender"),
        summary=data.get("summary"),
        result=data.get("result", {}),
    )


# --------------------------------------------------------------------------- #
# Action Operations
# --------------------------------------------------------------------------- #

def save_action(user_id: str, action: ProposedAction, notify: bool = True) -> ProposedAction:
    """
    Save an action. Creates new if id is None, updates if exists.
    Returns the saved action.
    
    Args:
        user_id: The user's ID
        action: The action to save
        notify: If True, send push notification for new actions (default True)
    """
    print(f"Saving action: {action.type}")
    db = get_db()
    
    action_data = _action_to_dict(action, user_id)
    
    # Check if this is an update (action has an ID and exists)
    if action.id is not None:
        # Try to update existing
        result = db.table("actions").update(action_data).eq("id", action.id).eq("user_id", user_id).execute()
        if result.data:
            return _dict_to_action(result.data[0])
    
    # Insert new action (remove id to let DB auto-generate)
    action_data.pop("id", None)
    result = db.table("actions").insert(action_data).execute()
    
    saved_action = _dict_to_action(result.data[0])
    
    # Send push notification for new actions
    if notify:
        try:
            from .push import notify_new_action
            notify_new_action(
                user_id=user_id,
                action=saved_action,
            )
        except Exception as e:
            # Don't fail action save if push notification fails
            print(f"Failed to send push notification: {e}")
    
    return saved_action


def get_action(user_id: str, action_id: int) -> Optional[ProposedAction]:
    """Get an action by its ID for a specific user."""
    db = get_db()
    
    result = db.table("actions").select("*").eq("id", action_id).eq("user_id", user_id).execute()
    
    if result.data:
        return _dict_to_action(result.data[0])
    return None


def list_actions(
    user_id: str,
    status: Optional[str] = None,
    context_id: Optional[str] = None,
    limit: Optional[int] = None,
    order_desc: bool = True,
) -> List[ProposedAction]:
    """
    List actions with optional filtering for a specific user.
    
    Args:
        user_id: The user's ID
        status: Filter by status (pending, executed, skipped, error)
        context_id: Filter by the context that triggered the action
        limit: Maximum number of items to return
        order_desc: If True, return newest first (by created_at)
    """
    db = get_db()
    
    query = db.table("actions").select("*").eq("user_id", user_id)
    
    if status is not None:
        query = query.eq("status", status)
    
    if context_id is not None:
        query = query.eq("context_id", context_id)
    
    # Order by created_at
    query = query.order("created_at", desc=order_desc)
    
    if limit is not None:
        query = query.limit(limit)
    
    result = query.execute()
    
    return [_dict_to_action(a) for a in result.data]


def update_action_status(user_id: str, action_id: int, status: str, result: Optional[Dict] = None) -> Optional[ProposedAction]:
    """Update an action's status. Returns the updated action or None if not found."""
    db = get_db()
    result_data = result if result else {}
    data = {
        "status": status,
        "result": result_data,
    }

    result = db.table("actions").update(data).eq("id", action_id).eq("user_id", user_id).execute()
    
    if result.data:
        return _dict_to_action(result.data[0])
    return None


def update_action_payload(user_id: str, action_id: int, payload: Dict[str, Any]) -> Optional[ProposedAction]:
    """Update an action's payload. Returns the updated action or None if not found."""
    db = get_db()
    
    result = db.table("actions").update({"payload": payload}).eq("id", action_id).eq("user_id", user_id).execute()
    
    if result.data:
        return _dict_to_action(result.data[0])
    return None


def get_actions_for_context(user_id: str, context_id: str) -> List[ProposedAction]:
    """Get all actions associated with a specific context for a user."""
    return list_actions(user_id=user_id, context_id=context_id)


# --------------------------------------------------------------------------- #
# Utility Functions
# --------------------------------------------------------------------------- #

def clear_all_actions(user_id: str):
    """Clear all stored actions for a user. Use with caution!"""
    db = get_db()
    db.table("actions").delete().eq("user_id", user_id).execute()
