"""
JSON file-based storage for context items and actions.

This module provides persistence for:
- ContextItem: Generic input contexts (emails, slack messages, etc.)
- ProposedAction: Actions generated by the LLM

Storage files are created in a `data/` directory relative to this module.
"""
from __future__ import annotations

import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from .config import settings
from .models import ActionType, ContextItem, ProposedAction, SourceType


# --------------------------------------------------------------------------- #
# Configuration
# --------------------------------------------------------------------------- #

CONTEXTS_FILE = settings.data_dir / "contexts.json"
ACTIONS_FILE = settings.data_dir / "actions.json"

# Auto-incrementing action ID
_next_action_id: int = 1

# --------------------------------------------------------------------------- #
# Low-level JSON helpers
# --------------------------------------------------------------------------- #

def _load_contexts_raw() -> List[Dict[str, Any]]:
    """Load raw context data from JSON file."""
    try:
        return json.loads(CONTEXTS_FILE.read_text())
    except (json.JSONDecodeError, FileNotFoundError):
        return []


def _save_contexts_raw(data: List[Dict[str, Any]]):
    """Save raw context data to JSON file."""
    CONTEXTS_FILE.write_text(json.dumps(data, indent=2, default=str))


def _load_actions_raw() -> List[Dict[str, Any]]:
    """Load raw action data from JSON file."""
    try:
        return json.loads(ACTIONS_FILE.read_text())
    except (json.JSONDecodeError, FileNotFoundError):
        return []


def _save_actions_raw(data: List[Dict[str, Any]]):
    """Save raw action data to JSON file."""
    ACTIONS_FILE.write_text(json.dumps(data, indent=2, default=str))


def _context_to_dict(ctx: ContextItem) -> Dict[str, Any]:
    """Convert ContextItem to dict for JSON storage."""
    return {
        "id": ctx.id,
        "source_type": ctx.source_type.value,
        "source_id": ctx.source_id,
        "timestamp": ctx.timestamp.isoformat(),
        "created_at": ctx.created_at.isoformat(),
        "content": ctx.content,
        "context_text": ctx.context_text,
        "sender": ctx.sender,
        "summary": ctx.summary,
        "processed": ctx.processed,
    }


def _dict_to_context(data: Dict[str, Any]) -> ContextItem:
    """Convert dict from JSON to ContextItem."""
    return ContextItem(
        id=data["id"],
        source_type=SourceType(data["source_type"]),
        source_id=data["source_id"],
        timestamp=datetime.fromisoformat(data["timestamp"]),
        created_at=datetime.fromisoformat(data["created_at"]),
        content=data.get("content", {}),
        context_text=data.get("context_text", ""),
        sender=data.get("sender"),
        summary=data.get("summary"),
        processed=data.get("processed", False),
    )


def _action_to_dict(action: ProposedAction) -> Dict[str, Any]:
    """Convert ProposedAction to dict for JSON storage."""
    return {
        "id": action.id,
        "context_id": action.context_id,
        "type": action.type.value,
        "payload": action.payload,
        "confidence": action.confidence,
        "status": action.status,
        "created_at": action.created_at.isoformat(),
        "source_type": action.source_type.value,
        "sender": action.sender,
        "summary": action.summary,
    }


def _dict_to_action(data: Dict[str, Any]) -> ProposedAction:
    """Convert dict from JSON to ProposedAction."""
    return ProposedAction(
        id=data["id"],
        context_id=data["context_id"],
        type=ActionType(data["type"]),
        payload=data.get("payload", {}),
        confidence=data.get("confidence", 0.5),
        status=data.get("status", "pending"),
        created_at=datetime.fromisoformat(data["created_at"]),
        source_type=SourceType(data.get("source_type")),
        sender=data.get("sender"),
        summary=data.get("summary"),
    )


# --------------------------------------------------------------------------- #
# Context Operations
# --------------------------------------------------------------------------- #

def save_context(context: ContextItem) -> ContextItem:
    """
    Save a context item. Updates if exists (by id), otherwise appends.
    Returns the saved context.
    """
    contexts = _load_contexts_raw()
    
    # Check for existing by id
    for i, ctx in enumerate(contexts):
        if ctx["id"] == context.id:
            contexts[i] = _context_to_dict(context)
            _save_contexts_raw(contexts)
            return context
    
    # Append new
    contexts.append(_context_to_dict(context))
    _save_contexts_raw(contexts)
    return context


def get_context(context_id: str) -> Optional[ContextItem]:
    """Get a context item by its internal ID."""
    contexts = _load_contexts_raw()
    for ctx in contexts:
        if ctx["id"] == context_id:
            return _dict_to_context(ctx)
    return None


def get_context_by_source_id(source_id: str, source_type: Optional[SourceType] = None) -> Optional[ContextItem]:
    """
    Get a context item by its source system ID.
    Used for deduplication - check if we've already ingested this item.
    """
    contexts = _load_contexts_raw()
    for ctx in contexts:
        if ctx["source_id"] == source_id:
            if source_type is None or ctx["source_type"] == source_type.value:
                return _dict_to_context(ctx)
    return None


def context_exists(source_id: str, source_type: Optional[SourceType] = None) -> bool:
    """Check if a context with the given source_id already exists (for deduplication)."""
    return get_context_by_source_id(source_id, source_type) is not None


def list_contexts(
    limit: Optional[int] = None,
    source_type: Optional[SourceType] = None,
    processed: Optional[bool] = None,
    order_desc: bool = True,
) -> List[ContextItem]:
    """
    List context items with optional filtering.
    
    Args:
        limit: Maximum number of items to return
        source_type: Filter by source type
        processed: Filter by processed state
        order_desc: If True, return newest first (by timestamp)
    """
    contexts = _load_contexts_raw()
    
    # Filter
    if source_type is not None:
        contexts = [c for c in contexts if c["source_type"] == source_type.value]
    
    if processed is not None:
        contexts = [c for c in contexts if c.get("processed", False) == processed]
    
    # Sort by timestamp
    contexts.sort(
        key=lambda c: c.get("timestamp", ""),
        reverse=order_desc
    )
    
    # Limit
    if limit is not None:
        contexts = contexts[:limit]
    
    return [_dict_to_context(c) for c in contexts]


def mark_context_processed(context_id: str) -> bool:
    """Mark a context item as processed. Returns True if found and updated."""
    contexts = _load_contexts_raw()
    
    for ctx in contexts:
        if ctx["id"] == context_id:
            ctx["processed"] = True
            _save_contexts_raw(contexts)
            return True
    
    return False


# --------------------------------------------------------------------------- #
# Action Operations
# --------------------------------------------------------------------------- #

def get_next_action_id() -> int:
    """Get the next available action ID."""
    global _next_action_id
    nid = _next_action_id
    _next_action_id += 1
    return nid


def save_action(action: ProposedAction, notify: bool = True) -> ProposedAction:
    """
    Save an action. Updates if exists (by id), otherwise appends.
    Returns the saved action.
    
    Args:
        action: The action to save
        notify: If True, send push notification for new actions (default True)
    """
    print(f"Saving action: {action.type}")
    actions = _load_actions_raw()
    
    # Check for existing by id
    is_new = True
    for i, act in enumerate(actions):
        if act["id"] == action.id:
            actions[i] = _action_to_dict(action)
            _save_actions_raw(actions)
            is_new = False
            return action
    
    # Append new
    actions.append(_action_to_dict(action))
    _save_actions_raw(actions)
    
    # Send push notification for new actions
    if is_new and notify:
        try:
            from .push import notify_new_action
            notify_new_action(
                action_type=action.type.value,
                summary=action.summary,
                action_id=action.id,
            )
        except Exception as e:
            # Don't fail action save if push notification fails
            print(f"Failed to send push notification: {e}")
    
    return action


def get_action(action_id: int) -> Optional[ProposedAction]:
    """Get an action by its ID."""
    actions = _load_actions_raw()
    for act in actions:
        if act["id"] == action_id:
            return _dict_to_action(act)
    return None


def list_actions(
    status: Optional[str] = None,
    context_id: Optional[str] = None,
    limit: Optional[int] = None,
    order_desc: bool = True,
) -> List[ProposedAction]:
    """
    List actions with optional filtering.
    
    Args:
        status: Filter by status (pending, executed, skipped, error)
        context_id: Filter by the context that triggered the action
        limit: Maximum number of items to return
        order_desc: If True, return newest first (by created_at)
    """
    actions = _load_actions_raw()
    
    # Filter
    if status is not None:
        actions = [a for a in actions if a.get("status") == status]
    
    if context_id is not None:
        actions = [a for a in actions if a.get("context_id") == context_id]
    
    # Sort by created_at
    actions.sort(
        key=lambda a: a.get("created_at", ""),
        reverse=order_desc
    )
    
    # Limit
    if limit is not None:
        actions = actions[:limit]
    
    return [_dict_to_action(a) for a in actions]


def update_action_status(action_id: int, status: str) -> Optional[ProposedAction]:
    """Update an action's status. Returns the updated action or None if not found."""
    actions = _load_actions_raw()
    
    for act in actions:
        if act["id"] == action_id:
            act["status"] = status
            _save_actions_raw(actions)
            return _dict_to_action(act)
    
    return None


def update_action_payload(action_id: int, payload: Dict[str, Any]) -> Optional[ProposedAction]:
    """Update an action's payload. Returns the updated action or None if not found."""
    actions = _load_actions_raw()
    
    for act in actions:
        if act["id"] == action_id:
            act["payload"] = payload
            _save_actions_raw(actions)
            return _dict_to_action(act)
    
    return None


def get_actions_for_context(context_id: str) -> List[ProposedAction]:
    """Get all actions associated with a specific context."""
    return list_actions(context_id=context_id)


# --------------------------------------------------------------------------- #
# History Retrieval (for LLM context)
# --------------------------------------------------------------------------- #

def get_recent_history(
    limit: int = 10,
    include_current: bool = False,
    exclude_context_id: Optional[str] = None,
) -> List[Tuple[ContextItem, List[ProposedAction]]]:
    """
    Get recent context items with their associated actions.
    Used to provide historical context to the LLM.
    
    Args:
        limit: Maximum number of context items to return
        include_current: If False, only return processed contexts
        exclude_context_id: Exclude this context from results (useful to exclude current)
    
    Returns:
        List of (ContextItem, List[ProposedAction]) tuples, newest first
    """
    # Get recent processed contexts (or all if include_current)
    processed_filter = None if include_current else True
    contexts = list_contexts(limit=limit, processed=processed_filter)
    
    # Exclude specific context if requested
    if exclude_context_id:
        contexts = [c for c in contexts if c.id != exclude_context_id]
    
    # Get actions for each context
    result: List[Tuple[ContextItem, List[ProposedAction]]] = []
    for ctx in contexts:
        actions = get_actions_for_context(ctx.id)
        result.append((ctx, actions))
    
    return result


# --------------------------------------------------------------------------- #
# Utility Functions
# --------------------------------------------------------------------------- #

def clear_all_data():
    """Clear all stored data. Use with caution!"""
    global _next_action_id
    _save_contexts_raw([])
    _save_actions_raw([])
    _next_action_id = 1


def get_stats() -> Dict[str, Any]:
    """Get storage statistics."""
    contexts = _load_contexts_raw()
    actions = _load_actions_raw()
    
    return {
        "total_contexts": len(contexts),
        "processed_contexts": sum(1 for c in contexts if c.get("processed", False)),
        "unprocessed_contexts": sum(1 for c in contexts if not c.get("processed", False)),
        "total_actions": len(actions),
        "pending_actions": sum(1 for a in actions if a.get("status") == "pending"),
        "executed_actions": sum(1 for a in actions if a.get("status") == "executed"),
        "skipped_actions": sum(1 for a in actions if a.get("status") == "skipped"),
        "contexts_by_type": {
            st.value: sum(1 for c in contexts if c.get("source_type") == st.value)
            for st in SourceType
        },
    }


# --------------------------------------------------------------------------- #
# Module Initialization
# --------------------------------------------------------------------------- #

def _init_action_id():
    """Initialize the next action ID based on existing actions."""
    global _next_action_id
    
    actions = _load_actions_raw()
    if actions:
        max_id = max(a.get("id", 0) for a in actions)
        _next_action_id = max_id + 1


# Initialize on module load
_init_action_id()
